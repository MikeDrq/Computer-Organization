|      | ADDER | ADDER |  PC   |  IM  |   GRF   |   GRF   |   GRF   |  GRF  |  ALU   |  ALU   |   DM    |   DM    |  SEXT  |  UEXT  |  HIGH  | SHIFTER |   JA   |      |      |
| :--: | :---: | :---: | :---: | :--: | :-----: | :-----: | :-----: | :---: | :----: | :----: | :-----: | :-----: | :----: | :----: | :----: | :-----: | :----: | ---- | ---- |
|      |   A   |   B   |       |      |  REG1   |  REG2   |  WREG   | WDATA |   A    |   B    | ADDRESS |  Write  |        |        |        |         |        |      |      |
| add  |  PC   |   4   | ADDER |  PC  | [25:21] | [20:16] | [15:11] |  ALU  | [REG1] | REG[2] |    /    |    /    |   /    |   /    |        |         |        |      |      |
| sub  |  PC   |   4   | ADDER |  PC  | [25:21] |    /    | [20:16] |  ALU  | [REG1] |  UEXT  |    /    |    /    |   /    | [15:0] |        |         |        |      |      |
| ori  |  PC   |   4   | ADDER |  PC  | [25:21] | [20:16] | [15:11] |  ALU  | [REG1] | REG[2] |    /    |    /    |   /    |   /    |        |         |        |      |      |
|  lw  |  PC   |   4   | ADDER |  PC  | [25:21] |    /    | [20:16] |  DM   | [REG1] |  SEXT  |   ALU   |    /    | [15:0] |   /    |        |         |        |      |      |
|  sw  |  PC   |   4   | ADDER |  PC  | [25:21] |    /    | [20:16] |   /   | [REG1] |  SEXT  |   ALU   | [20:16] | [15:0] |   /    |        |         |        |      |      |
| beq  | PC+4  | shift | ADDER |  PC  | [25:21] | [20:16] |    /    |   /   | [REG1] | [REG2] |    /    |    /    | [15:0] |   /    |   /    |  SEXT   |        |      |      |
| lui  |  PC   |   4   | ADDER |  PC  |    /    |    /    | [20:16] |  ALU  |   0    |  HIGH  |    /    |    /    |   /    |   /    | [15:0] |         |        |      |      |
| nop  |       |       |       |      |         |         |         |       |        |        |         |         |        |        |        |         |        |      |      |
|  J   |  PC   |  JA   | ADDER |  PC  |         |         |         |       |        |        |         |         |        |        |        |         | [25:0] |      |      |
|      |       |       |       |      |         |         |         |       |        |        |         |         |        |        |        |         |        |      |      |
|      |       |       |       |      |         |         |         |       |        |        |         |         |        |        |        |         |        |      |      |
|      |       |       |       |      |         |         |         |       |        |        |         |         |        |        |        |         |        |      |      |
|      |       |       |       |      |         |         |         |       |        |        |         |         |        |        |        |         |        |      |      |

## 一、 PC

读取指令的地址

## 二、NPC

计算下一指令的地址

## 三、Controller

控制信号：

RegDst:控制写入GRF的寄存器的选择 0:写入RT，1写入RD

AluSrc控制ALU的第二个运算数是数字是来源于寄存器还是立即数

MemtoReg控制输入寄存器的数据来源于ALU还是DM

RegWrite控制GRF是否写入数据

MemRead和MemWrite分别控制DM的读写

ALUcontrol控制ALU的进行什么运算

Sign控制扩展的种类。

branch：控制分支

j：控制跳转

## 四、EXT

控制扩展的种类

## 五、DM

读写内存



## 六、思考题

1. 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

   通用寄存器,PC,DM：存储

   ALU,EXT,控制单元等其他大部分组件位状态转移组件

2. 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

   合理，RAM速度快于ROM，容量相对较大，对于频繁访问内存可以提高速度，可以通过复位信号清除，方便下一次使用。ROM存储指令，除非认为清除，否则不会自动丢失，方便对指令的执行。寄存器的存储效率更高，GRF再指令执行中会被频繁调用，应用存储速度最快的寄存器。

3. 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

   是

   NPC模块，用于判断下一条指令的位置，因为会有跳转指令。

   判断是否位跳转类的指令，如果不是，则直接PC+4，否则，跟据跳转类型，有条件跳转及条件是否达到，无条件跳转来判断下一指令地址，用多路选择器实现。

   SPLITTER模块，同意对指令进行拆分，然后送入控制单元。

   思路：每一个信号都拆出[31:26],[25:21],[20:16],[15:11],[10:6],[5:0],[15:0],[25:0]这些位，同意送入控制单元进行处理。

4. 事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

   如果指令是nop，可以看作是sll把0左移0位再存入0，所以不会对GRF,DM,PC产生影响，只需注意regwrite信号作用时指令非0即可。

5. 上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。

   mars中指令从3000开始存储，logisim中指令和数据分开存储，起始地址均为0，增加一个PC地址减去3000的模块

6. 阅读 Pre 的 [“MIPS 指令集及汇编语言”](https://cscore-buaa-edu-cn.vpn.buaa.edu.cn:8118/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

   首先，测试样例中的指令比全面，正数负数都有考虑，同时跳转指令既有满足跳转条件的情况也有不满足的情况，但是指令数以及数据强度略有欠缺。但是有些边界条件没有考虑，比如2147483648附近的数字，跳转是否可以跳到有一定距离的地址，0号寄存器是否会被写入等等。
